Truc a garder en mémoire lorsqu'on ecrit du code :)

RENDU 1
les fonctionnalités du C++ étudiées dans les 4 premiers CM (octobre à décembre)

resume CM:
CM1:
   const, pointeurs, références, fonction, surcharge de fonction,
   surcharge d'opérateur, fonction inline, allocation et libération dynamiques,
   mots-clé new et delete, référence universelle,  classe, instance,
   variable/attribut et fonction membres
   modificateurs : public, protected, private
   constructeurs, destructeur, liste d'initialisations
   attribut const, fonction const, mots-clé mutable et static
   classe string, RAII

CM2
     Les espaces de noms,
     Héritage
     Polymorphisme
     Appels des constructeurs par défaut, de conversion, de copie
     Surcharge d'opérateurs, opérateurs membres, opérateurs externes, opérateurs amis
     Espaces de nommage

CM3
    Héritage privé dit d'implémentation
    héritage simple dit de comportement, redéfinition de méthode, polymorphisme, méthodes virtuelle et virtuelle pure (abstraite),
    héritage multiple, problème du losange/diamant et héritage virtuel

    Conversions : downcasting, upcasting avec le dynamic_cast , static_cast et ses dangers
    copies virtuelles dynamiques,
    opérateur ami et polymorphisme (operator<< défini uniquement dans la classe de base et appelant une fonction membre virtuelle)
    nécessité de rendre le destructeur virtuel.
    C++11 mots-clé override et final, comme en Java!
    Introduction aux Templates
    Les itérateurs de la STL (iterator, const_iterator, fonctions membres begin, cbegin, end et cend, les mêmes fonctions mais en tant que fonctions externes).
    Templates compléments
    Templates variadiques
    Foncteurs, foncteurs génériques, boucle for_each et foncteur

CM4
    Compilation, nullptr, void *, énumérations fortement typées, initialisation des constantes sur place ou dans le constructeur
    assertions assert et static_assert
    prédicats is_base_of<T1, T2>, is_default_constructible<T>, is_constructible<T1, T2, ....>
    méthode non définie : mot-clé delete
    délégation des constructeurs, héritage des constructeurs (using A::A pour toute classe mère A)
    Inférence de types : auto et decltype
    syntaxe alternative des fonctions :auto et  -> pour le type de retour
    syntaxe alternative des itérateurs : auto et const auto &
    syntaxe alternative des fonctions : adaptateur générique de fonction std::function pour un foncteur(objet-fonction), une fonction membre d'une classe (méthode), une fonction externe, ou encore une lambda (fonction anonyme).
    listes d'initialisation ; initializer_list est un tableau de références
    les boucles foreach
    type Array
    désactivation des conversions implicites : mot-clé explicit
    lambda fonction
    algorithm : std::count_if, for_each ...
    méthode de tri : sort
    constexpr versus templates récursifs


utiliser des classes STL (au moins 3 : list, map, set ....)

créer au moins une classe template

inférence de type, lambda, constexpr


RENDU 2
 les fonctionnalités avancées du C++ étudiées dans les 2 derniers CM de janvier

pointeurs intelligents, move semantics, exceptions

Voila si tu lis ceci c'est que tu n'a pas tous passé comme un bourrin :)
Si tu peux juste prendre quelque truc dedans ou commencé à penser pour mettre les fonctionnalité du rendu 2
ça serai super =)

Si tu a besoin que je mette au clair cette partie ou que je rajoute des truc dis moi.