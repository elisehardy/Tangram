# Consignes


## Rendu 1 (Début février)

- [ ] Les fonctionnalités du C++ étudiées dans les 4 premiers CM (octobre à décembre)

- [X] Utiliser 1 classe STL (std::vector)

- [X] Utiliser 2 classe STL (std::unordered_map)

- [X] Utiliser 3+ classe STL (std::map, std::stack)

- [X] Créer au moins une classe template

- [X] Inférence de type, lambda, constexpr

* CM1:
- [X] const, pointeurs, références, fonction, surcharge de fonction

- [X] surcharge d'opérateur, fonction inline, allocation et libération dynamiques

- [X] mots-clé new et delete, référence universelle,  classe, instance

- [X] variable/attribut et fonction membres

- [X] modificateurs : public, protected, private

- [X] constructeurs, destructeur, liste d'initialisations

- [X] attribut const, fonction const, mots-clé mutable et static

- [ ] classe string, RAII

* CM2
- [X] Les espaces de noms

- [X] Héritage

- [X] Polymorphisme

- [X] Appels des constructeurs par défaut, de conversion, de copie

- [X] Surcharge d'opérateurs, opérateurs membres, opérateurs externes, opérateurs amis

- [X] Espaces de nommage


* CM3

- [X] Héritage privé dit d'implémentation

- [X] héritage simple dit de comportement, redéfinition de méthode, polymorphisme, méthodes virtuelle et virtuelle pure (abstraite)

- [X] héritage multiple, problème du losange/diamant et héritage virtuel



- [X] Conversions : downcasting, upcasting avec le dynamic_cast , static_cast et ses dangers

- [ ] copies virtuelles dynamiques,

- [X] opérateur ami et polymorphisme (operator<< défini uniquement dans la classe de base et appelant une fonction membre virtuelle)

- [X] nécessité de rendre le destructeur virtuel.

- [X] C++11 mots-clé override et final, comme en Java!

- [X] Introduction aux Templates

- [X] Les itérateurs de la STL (iterator, const_iterator, fonctions membres begin, cbegin, end et cend, les mêmes fonctions mais en tant que fonctions externes)

- [ ] Templates compléments

- [X] Templates variadiques

- [X] Foncteurs, foncteurs génériques, boucle for_each et foncteur

* CM4

- [X] Compilation, nullptr, void *, énumérations fortement typées, initialisation des constantes sur place ou dans le constructeur

- [ ] assertions assert et static_assert

- [ ] prédicats is_base_of<T1, T2>, is_default_constructible<T>, is_constructible<T1, T2, ....>

- [X] méthode non définie : mot-clé delete

- [X] délégation des constructeurs, héritage des constructeurs (using A::A pour toute classe mère A)

- [X] Inférence de types : auto et decltype

- [X] syntaxe alternative des fonctions :auto et  -> pour le type de retour

- [X] syntaxe alternative des itérateurs : auto et const auto &

- [X] syntaxe alternative des fonctions : adaptateur générique de fonction std::function pour un foncteur(objet-fonction), une fonction membre d'une classe (méthode), une fonction externe, ou encore une lambda (fonction anonyme).

- [ ] listes d'initialisation ; initializer_list est un tableau de références

- [X] les boucles foreach

- [X] type Array

- [X] désactivation des conversions implicites : mot-clé explicit

- [X] lambda fonction

- [X] algorithm : std::count_if, for_each ...

- [X] méthode de tri : sort

- [ ] constexpr versus templates récursifs

## Rendu 2

- [ ] Les fonctionnalités avancées du C++ étudiées dans les 2 derniers CM de janvier

- [ ] Pointeurs intelligents, move semantics, exceptions
